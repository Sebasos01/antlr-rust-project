diff --git a/src/Main.java b/src/Main.java
index cb79f79..a2af4d7 100644
--- a/src/Main.java
+++ b/src/Main.java
@@ -1,41 +1,45 @@
 import org.antlr.v4.runtime.*;
 import org.antlr.v4.runtime.tree.*;
 
 import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.nio.file.StandardOpenOption;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.FileWriter;
 import java.util.List;
 import java.util.Set;
 import java.util.HashSet;
+import java.util.regex.Pattern;
+import java.io.BufferedReader;
+import java.io.InputStream;
+import java.io.ByteArrayOutputStream;
 import java.util.stream.Stream;
 
 /**
  * Main application to recursively parse Rust source files (.rs) within a folder,
  * log any syntax errors to a single log file (named after the repository and stored
  * in a dedicated folder), and optionally (in debug mode) print the tokens and parse
  * tree for a specified file.
  *
  * Usage:
  *   java RustParserApp <folder_path> [print <debugFileName>]
  *
  * When "print" is provided as the second parameter along with a third parameter (the
  * name of the Rust file for which tokens and tree output are desired), then that file's
  * tokens and parse tree are written to "output_tokens.txt" and "output_tree.txt"
  * respectively, stored inside the log folder.
  */
 public class Main {
 
     public static void main(String[] args) {
         // Expected usage:
         // java RustParserApp <folder_path> [print <debugFileName>]
         String folderPathStr;
         final boolean debugMode;
         final String debugFileName;
         final String toIgnorePathStr;
@@ -173,50 +177,93 @@ public class Main {
                     data.paths.add(trimmed);
                 } else {
                     data.names.add(trimmed);
                 }
             });
         } catch (IOException e) {
             System.err.println("Failed to read ignore file: " + ignoreFile + " - " + e.getMessage());
         }
         return data;
     }
 
     /**
      * Determines if the given file should be ignored based on the loaded ignore data.
      */
     private static boolean shouldIgnore(Path file, Path root, IgnoreData data) {
         if (data.paths.isEmpty() && data.names.isEmpty()) {
             return false;
         }
         String rel = root.relativize(file).toString().replace('\\', '/');
         if (data.paths.contains(rel)) {
             return true;
         }
         return data.names.contains(file.getFileName().toString());
     }
 
+    /**
+     * Runs `rustc +nightly -Z unpretty=ast-tree <file>` and returns true if the
+     * command produces no output on stderr.
+     */
+    private static boolean rustcProducesNoStderr(Path file) {
+        ProcessBuilder pb = new ProcessBuilder(
+                "rustc", "+nightly", "-Z", "unpretty=ast-tree", file.toString());
+        pb.redirectOutput(ProcessBuilder.Redirect.DISCARD);
+        ByteArrayOutputStream err = new ByteArrayOutputStream();
+        try {
+            Process proc = pb.start();
+            try (InputStream es = proc.getErrorStream()) {
+                byte[] buf = new byte[8192];
+                int n;
+                while ((n = es.read(buf)) != -1) {
+                    err.write(buf, 0, n);
+                }
+            }
+            proc.waitFor();
+        } catch (Exception e) {
+            return false;
+        }
+        return err.size() == 0;
+    }
+
+    /**
+     * Checks if the file contains a comment matching the pattern `//.*ERROR`.
+     */
+    private static boolean hasErrorComment(Path file) {
+        Pattern pattern = Pattern.compile("//.*ERROR", Pattern.CASE_INSENSITIVE);
+        try (BufferedReader reader = Files.newBufferedReader(file, StandardCharsets.UTF_8)) {
+            String line;
+            while ((line = reader.readLine()) != null) {
+                if (pattern.matcher(line).find()) {
+                    return true;
+                }
+            }
+        } catch (IOException e) {
+            return true;
+        }
+        return false;
+    }
+
     /**
      * Custom error listener that logs parsing errors to a shared BufferedWriter.
      * It loads the file lines (once per file) for reporting the specific line content
      * where an error occurs.
      */
     private static class RustErrorListener extends BaseErrorListener {
         private final String filePath;
         private final List<String> lines;
         private final BufferedWriter logWriter;
 
         RustErrorListener(String filePath, List<String> lines, BufferedWriter logWriter) {
             this.filePath = filePath;
             this.lines = lines;
             this.logWriter = logWriter;
         }
 
         @Override
         public void syntaxError(Recognizer<?, ?> recognizer,
                                 Object offendingSymbol,
                                 int line,
                                 int charPositionInLine,
                                 String msg,
                                 RecognitionException e) {
             // Retrieve the content of the line where the error occurred (if available)
             String lineContent = "";
@@ -247,50 +294,55 @@ public class Main {
      * Parses a single Rust source file using ANTLR. Logs syntax errors via the provided logWriter.
      * If debugMode is enabled and the current file's name matches the specified debug file path,
      * outputs the token stream and parse tree to "output_tokens.txt" and "output_tree.txt" stored in logFolder.
      *
      * @param rustFile      The .rs file to parse.
      * @param logWriter     Writer for logging errors.
      * @param debugMode     If true, indicates that token and parse tree output is desired.
      * @param debugFilePath The name of the file for which tokens and tree should be printed.
      * @param logFolder     The folder where debug output should be stored.
      * @param rootPath      Root folder being scanned (for relative path output).
      * @param fileListWriter Writer to record processed file paths.
      */
     private static void parseRustFile(Path rustFile, BufferedWriter logWriter, boolean debugMode,
                                       String debugFilePath, Path logFolder, Path rootPath,
                                       BufferedWriter fileListWriter) {
         try {
             // Record the path of this file relative to the scanned folder
             try {
                 String rel = rootPath.relativize(rustFile).toString().replace('\\', '/');
                 fileListWriter.write(rel);
                 fileListWriter.newLine();
                 fileListWriter.flush();
             } catch (IOException ex) {
                 System.err.println("Failed to record parsed file: " + rustFile + " - " + ex.getMessage());
             }
+
+            // Only parse if rustc reports no errors and the file lacks '//.*ERROR'
+            if (!rustcProducesNoStderr(rustFile) || hasErrorComment(rustFile)) {
+                return;
+            }
             // Read all lines (for error reporting)
             List<String> lines = Files.readAllLines(rustFile, StandardCharsets.UTF_8);
             // Create a CharStream from the file
             CharStream input = CharStreams.fromPath(rustFile, StandardCharsets.UTF_8);
 
             // Initialize lexer and parser
             RustLexer lexer = new RustLexer(input);
             CommonTokenStream tokens = new CommonTokenStream(lexer);
             RustParser parser = new RustParser(tokens);
 
             // Attach the custom error listener
             RustErrorListener errorListener = new RustErrorListener(rustFile.toString(), lines, logWriter);
             lexer.removeErrorListeners();
             parser.removeErrorListeners();
             lexer.addErrorListener(errorListener);
             parser.addErrorListener(errorListener);
 
             // Use default error recovery strategy
             parser.setErrorHandler(new DefaultErrorStrategy());
 
             // Parse using the top-level rule (assuming 'crate' is the correct start rule)
             ParseTree tree = parser.crate();
 
             // If debug mode is enabled and this file matches the specified debug file name, output tokens and tree.
             if (debugMode && debugFilePath != null) {

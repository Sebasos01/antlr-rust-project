Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-multipart/src/multipart.rs
    Line        : 419
    Column      : 59
    Error       : no viable alternative at input 'if self.state == State::Eof {\n            Poll::Ready(None)\n        } else {\n            // release field\n            loop {\n                // Nested multipart streams of fields has to be consumed\n                // before switching to next\n                if safety.current() {\n                    let stop = match self.item {\n                        Item::Field(ref mut field) => match field.borrow_mut().poll(safety) {\n                            Poll::Pending => return Poll::Pending,\n                            Poll::Ready(Some(Ok(_))) => continue,\n                            Poll::Ready(Some(Err(err))) => return Poll::Ready(Some(Err(err))),\n                            Poll::Ready(None) => true,\n                        },\n                        Item::None => false,\n                    };\n                    if stop {\n                        self.item = Item::None;\n                    }\n                    if let Item::None = self.item {\n                        break;\n                    }\n                }\n            }\n\n            let field_headers = if let Some(mut payload) = self.payload.get_mut(safety) {\n                match self.state {\n                    // read until first boundary\n                    State::FirstBoundary => {\n                        match Inner::skip_until_boundary(&mut payload, &self.boundary)? {\n                            None => return Poll::Pending,\n                            Some(eof) => {\n                                if eof {\n                                    self.state = State::Eof;\n                                    return Poll::Ready(None);\n                                } else {\n                                    self.state = State::Headers;\n                                }\n                            }\n                        }\n                    }\n\n                    // read boundary\n                    State::Boundary => match Inner::read_boundary(&mut payload, &self.boundary)? {\n                        None => return Poll::Pending,\n                        Some(eof) => {\n                            if eof {\n                                self.state = State::Eof;\n                                return Poll::Ready(None);\n                            } else {\n                                self.state = State::Headers;\n                            }\n                        }\n                    },\n\n                    _ => {}\n                }\n\n                // read field headers for next field\n                if self.state == State::Headers {\n                    if let Some(headers) = Inner::read_field_headers(&mut payload)? {\n                        self.state = State::Boundary;\n                        headers\n                    } else {\n                        return Poll::Pending;\n                    }\n                } else {\n                    unreachable!()\n                }\n            } else {\n                log::debug!("NotReady: field is in flight");\n                return Poll::Pending;\n            };\n\n            let field_content_disposition = field_headers\n                .get(&header::CONTENT_DISPOSITION)\n                .and_then(|cd| ContentDisposition::from_raw(cd).ok())\n                .filter(|content_disposition| {\n                    matches!(\n                        content_disposition.disposition,\n                        header::DispositionType::FormData,\n                    )\n                });\n\n            let form_field_name = if self.content_type.subtype() == mime::FORM_DATA {\n                // According to RFC 7578 ยง4.2, which relates to "multipart/form-data" requests\n                // specifically, fields must have a Content-Disposition header, its disposition\n                // type must be set as "form-data", and it must have a name parameter.\n\n                let Some(cd) = &field_content_disposition else'
    Line Content:                 let Some(cd) = &field_content_disposition else {
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-multipart/src/multipart.rs
    Line        : 331
    Column      : 11
    Error       : extraneous input 'else' expecting {<EOF>, 'const', 'crate', 'enum', 'extern', 'fn', 'impl', 'mod', 'pub', 'self', 'static', 'struct', 'super', 'trait', 'type', 'unsafe', 'use', 'async', 'union', 'macro_rules', '$crate', NON_KEYWORD_IDENTIFIER, RAW_IDENTIFIER, '::', '#'}
    Line Content:         } else {
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-multipart/src/multipart.rs
    Line        : 398
    Column      : 17
    Error       : mismatched input '}' expecting ';'
    Line Content:                 }
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-multipart/src/multipart.rs
    Line        : 401
    Column      : 17
    Error       : extraneous input 'return' expecting {<EOF>, 'const', 'crate', 'enum', 'extern', 'fn', 'impl', 'mod', 'pub', 'self', 'static', 'struct', 'super', 'trait', 'type', 'unsafe', 'use', 'async', 'union', 'macro_rules', '$crate', NON_KEYWORD_IDENTIFIER, RAW_IDENTIFIER, '::', '#'}
    Line Content:                 return Poll::Pending;
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-multipart/src/multipart.rs
    Line        : 412
    Column      : 17
    Error       : mismatched input '}' expecting ';'
    Line Content:                 });
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-multipart/src/field.rs
    Line        : 372
    Column      : 9
    Error       : mismatched input 'else' expecting {'as', '+', '-', '*', '/', '%', '^', '&', '|', '&&', '||', '+=', '-=', '*=', '/=', '%=', '^=', '&=', '|=', '<<=', '>>=', '=', '==', '!=', '>', '<', '>=', '<=', '.', '..', '..=', ',', '::', '?', '[', '(', ')'}
    Line Content:         else {

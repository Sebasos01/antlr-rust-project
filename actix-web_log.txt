Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/awc/src/middleware/mod.rs
    Line        : 12
    Column      : 19
    Error       : mismatched input ':' expecting {'where', '=', '<', ';'}
    Line Content:     type Transform: Service<Req>;
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-router/src/quoter.rs
    Line        : 108
    Column      : 27
    Error       : rule shl failed predicate: {this.next('<')}?
    Line Content:     Some(((d_high as u8) << 4) | (d_low as u8))
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-router/src/quoter.rs
    Line        : 108
    Column      : 29
    Error       : mismatched input '4' expecting {'crate', 'extern', 'fn', 'for', 'impl', 'self', 'Self', 'super', 'unsafe', 'dyn', ''static', 'macro_rules', ''_', '$crate', NON_KEYWORD_IDENTIFIER, RAW_IDENTIFIER, LIFETIME_OR_LABEL, '*', '!', '&', '<', '_', '::', '?', '[', '('}
    Line Content:     Some(((d_high as u8) << 4) | (d_low as u8))
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-router/src/quoter.rs
    Line        : 122
    Column      : 25
    Error       : rule shr failed predicate: {this.next('>')}?
    Line Content:         self.array[(ch >> 3) as usize] |= 0b1 << (ch & 0b111)
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-router/src/quoter.rs
    Line        : 122
    Column      : 48
    Error       : rule shl failed predicate: {this.next('<')}?
    Line Content:         self.array[(ch >> 3) as usize] |= 0b1 << (ch & 0b111)
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-router/src/quoter.rs
    Line        : 122
    Column      : 54
    Error       : no viable alternative at input '(ch &'
    Line Content:         self.array[(ch >> 3) as usize] |= 0b1 << (ch & 0b111)
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-router/src/quoter.rs
    Line        : 130
    Column      : 25
    Error       : rule shr failed predicate: {this.next('>')}?
    Line Content:         self.array[(ch >> 3) as usize] & (0b1 << (ch & 0b111)) != 0
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-router/src/quoter.rs
    Line        : 130
    Column      : 48
    Error       : rule shl failed predicate: {this.next('<')}?
    Line Content:         self.array[(ch >> 3) as usize] & (0b1 << (ch & 0b111)) != 0
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-router/src/quoter.rs
    Line        : 130
    Column      : 54
    Error       : no viable alternative at input '(ch &'
    Line Content:         self.array[(ch >> 3) as usize] & (0b1 << (ch & 0b111)) != 0
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-router/src/resource_path.rs
    Line        : 7
    Column      : 14
    Error       : mismatched input ':' expecting {'where', '=', '<', ';'}
    Line Content:     type Path: ResourcePath;
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-web/src/extract.rs
    Line        : 67
    Column      : 15
    Error       : mismatched input ':' expecting {'where', '=', '<', ';'}
    Line Content:     type Error: Into<Error>;
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-web/src/extract.rs
    Line        : 86
    Column      : 16
    Error       : mismatched input ':' expecting {'where', '=', '<', ';'}
    Line Content:     type Future: Future<Output = Result<Self, Self::Error>>;
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-web/src/response/responder.rs
    Line        : 40
    Column      : 14
    Error       : mismatched input ':' expecting {'where', '=', '<', ';'}
    Line Content:     type Body: MessageBody + 'static;
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-web/src/handler.rs
    Line        : 91
    Column      : 16
    Error       : mismatched input ':' expecting {'where', '=', '<', ';'}
    Line Content:     type Future: Future<Output = Self::Output>;
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-web/benches/responder.rs
    Line        : 12
    Column      : 16
    Error       : mismatched input ':' expecting {'where', '=', '<', ';'}
    Line Content:     type Future: Future<Output = Result<HttpResponse, Self::Error>>;
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-multipart/src/form/mod.rs
    Line        : 33
    Column      : 16
    Error       : mismatched input ':' expecting {'where', '=', '<', ';'}
    Line Content:     type Future: Future<Output = Result<Self, MultipartError>>;
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-multipart/src/form/mod.rs
    Line        : 55
    Column      : 16
    Error       : mismatched input ':' expecting {'where', '=', '<', ';'}
    Line Content:     type Future: Future<Output = Result<(), MultipartError>>;
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-multipart/src/multipart.rs
    Line        : 419
    Column      : 59
    Error       : no viable alternative at input 'if self.state == State::Eof {\n            Poll::Ready(None)\n        } else {\n            // release field\n            loop {\n                // Nested multipart streams of fields has to be consumed\n                // before switching to next\n                if safety.current() {\n                    let stop = match self.item {\n                        Item::Field(ref mut field) => match field.borrow_mut().poll(safety) {\n                            Poll::Pending => return Poll::Pending,\n                            Poll::Ready(Some(Ok(_))) => continue,\n                            Poll::Ready(Some(Err(err))) => return Poll::Ready(Some(Err(err))),\n                            Poll::Ready(None) => true,\n                        },\n                        Item::None => false,\n                    };\n                    if stop {\n                        self.item = Item::None;\n                    }\n                    if let Item::None = self.item {\n                        break;\n                    }\n                }\n            }\n\n            let field_headers = if let Some(mut payload) = self.payload.get_mut(safety) {\n                match self.state {\n                    // read until first boundary\n                    State::FirstBoundary => {\n                        match Inner::skip_until_boundary(&mut payload, &self.boundary)? {\n                            None => return Poll::Pending,\n                            Some(eof) => {\n                                if eof {\n                                    self.state = State::Eof;\n                                    return Poll::Ready(None);\n                                } else {\n                                    self.state = State::Headers;\n                                }\n                            }\n                        }\n                    }\n\n                    // read boundary\n                    State::Boundary => match Inner::read_boundary(&mut payload, &self.boundary)? {\n                        None => return Poll::Pending,\n                        Some(eof) => {\n                            if eof {\n                                self.state = State::Eof;\n                                return Poll::Ready(None);\n                            } else {\n                                self.state = State::Headers;\n                            }\n                        }\n                    },\n\n                    _ => {}\n                }\n\n                // read field headers for next field\n                if self.state == State::Headers {\n                    if let Some(headers) = Inner::read_field_headers(&mut payload)? {\n                        self.state = State::Boundary;\n                        headers\n                    } else {\n                        return Poll::Pending;\n                    }\n                } else {\n                    unreachable!()\n                }\n            } else {\n                log::debug!("NotReady: field is in flight");\n                return Poll::Pending;\n            };\n\n            let field_content_disposition = field_headers\n                .get(&header::CONTENT_DISPOSITION)\n                .and_then(|cd| ContentDisposition::from_raw(cd).ok())\n                .filter(|content_disposition| {\n                    matches!(\n                        content_disposition.disposition,\n                        header::DispositionType::FormData,\n                    )\n                });\n\n            let form_field_name = if self.content_type.subtype() == mime::FORM_DATA {\n                // According to RFC 7578 ยง4.2, which relates to "multipart/form-data" requests\n                // specifically, fields must have a Content-Disposition header, its disposition\n                // type must be set as "form-data", and it must have a name parameter.\n\n                let Some(cd) = &field_content_disposition else'
    Line Content:                 let Some(cd) = &field_content_disposition else {
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-multipart/src/multipart.rs
    Line        : 331
    Column      : 11
    Error       : extraneous input 'else' expecting {<EOF>, 'const', 'crate', 'enum', 'extern', 'fn', 'impl', 'mod', 'pub', 'self', 'static', 'struct', 'super', 'trait', 'type', 'unsafe', 'use', 'async', 'union', 'macro_rules', '$crate', NON_KEYWORD_IDENTIFIER, RAW_IDENTIFIER, '::', '#'}
    Line Content:         } else {
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-multipart/src/multipart.rs
    Line        : 398
    Column      : 17
    Error       : mismatched input '}' expecting ';'
    Line Content:                 }
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-multipart/src/multipart.rs
    Line        : 401
    Column      : 17
    Error       : extraneous input 'return' expecting {<EOF>, 'const', 'crate', 'enum', 'extern', 'fn', 'impl', 'mod', 'pub', 'self', 'static', 'struct', 'super', 'trait', 'type', 'unsafe', 'use', 'async', 'union', 'macro_rules', '$crate', NON_KEYWORD_IDENTIFIER, RAW_IDENTIFIER, '::', '#'}
    Line Content:                 return Poll::Pending;
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-multipart/src/multipart.rs
    Line        : 412
    Column      : 17
    Error       : mismatched input '}' expecting ';'
    Line Content:                 });
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-multipart/src/field.rs
    Line        : 372
    Column      : 9
    Error       : mismatched input 'else' expecting {'as', '+', '-', '*', '/', '%', '^', '&', '|', '&&', '||', '+=', '-=', '*=', '/=', '%=', '^=', '&=', '|=', '<<=', '>>=', '=', '==', '!=', '>', '<', '>=', '<=', '.', '..', '..=', ',', '::', '?', '[', '(', ')'}
    Line Content:         else {
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-http/src/header/into_pair.rs
    Line        : 13
    Column      : 15
    Error       : mismatched input ':' expecting {'where', '=', '<', ';'}
    Line Content:     type Error: Into<HttpError>;
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-http/src/header/into_value.rs
    Line        : 10
    Column      : 15
    Error       : mismatched input ':' expecting {'where', '=', '<', ';'}
    Line Content:     type Error: Into<HttpError>;
Rust Parse Error:
    File Path   : /home/socub/U/tesis/rust_repos/actix-web/actix-http/src/body/message_body.rs
    Line        : 60
    Column      : 15
    Error       : mismatched input ':' expecting {'where', '=', '<', ';'}
    Line Content:     type Error: Into<Box<dyn StdError>>;
